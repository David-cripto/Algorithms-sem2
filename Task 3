#include <iostream>
#include <vector>

using std::cin;
using std::cout;
using std::vector;

class Graph {
private:
	class Gr_el {
	public:
		int time_in;
		int time_out;
		int color;
		int number;
		int parent;
		int indeg;
		int outdeg;
		Gr_el(int number) {
			this->number = number;
		}
	};
	int time;
	vector<vector<Gr_el*>> conn;
	vector<Gr_el*> ver;
	vector<Gr_el*> ver_cond;
	vector<Gr_el*> sort_ver;
	vector<vector<Gr_el*>> peaks;
	vector<vector<Gr_el*>> peaks_cond;
	vector<vector<Gr_el*>> inv_peaks;
	void DFS_vis(Gr_el& u, vector<vector<Gr_el*>>& p);
	void DFS_vis1(Gr_el& u, vector<vector<Gr_el*>>& p, vector<Gr_el*>& temp);
	void con_check(Gr_el& u, vector<Gr_el*>& temp);
	void set_peaks_cond(int in, int to);
public:
	Graph(int n);
	~Graph();
	void set_ver(int in, int to);
	void DFS_inv();
	void DFS();
	void con();
	void cond();
};

int main() {
	int n, m;
	cin >> n >> m;
	Graph gr(n);
	for (int i = 0; i < m; ++i) {
		int f_v, s_v;
		cin >> f_v >> s_v;
		gr.set_ver(f_v, s_v);
	}
	gr.DFS_inv();
	gr.DFS();
	gr.cond();
	return 0;
}

Graph::Graph(int n){
	for (int i = 0; i < n + 1; ++i) {
		Gr_el* temp = new Gr_el(i);
		ver.push_back(temp);
		vector<Gr_el*> temp1;
		peaks.push_back(temp1);
		inv_peaks.push_back(temp1);
	}
}

Graph::~Graph(){
	for (int i = 0; i < ver.size(); ++i)
		delete ver[i];
	for (int i = 0; i < ver_cond.size(); ++i)
		delete ver_cond[i];
}

void Graph::set_ver(int in, int to){
	peaks[in].push_back(ver[to]);
	inv_peaks[to].push_back(ver[in]);
}

void Graph::set_peaks_cond(int in, int to){
	peaks_cond[in].push_back(ver_cond[to]);
}

void Graph::DFS_inv(){
	for (int i = 0; i < ver.size(); ++i) {
		ver[i]->color = 0;
		ver[i]->parent = -1;
	}
	time = 0;
	for (int i = 0; i < ver.size(); ++i) {
		if (ver[i]->color == 0)
			DFS_vis(*ver[i], inv_peaks);
	}
}

void Graph::DFS(){
	for (int i = 0; i < ver.size(); ++i) {
		ver[i]->color = 0;
		ver[i]->parent = -1;
	}
	time = 0;
	for (int i = sort_ver.size() - 1; i > 0; --i) {
		vector<Gr_el*> temp;
		if (sort_ver[i]->color == 0)
			DFS_vis1(*sort_ver[i], peaks, temp);
		if (temp.size() != 0)
			conn.push_back(temp);
	}
}

void Graph::cond() {
	if (conn.size() == 1) {
		cout << 0;
		return;
	}

	for (int i = 0; i < conn.size(); ++i) {
		Gr_el* temp = new Gr_el(i);
		ver_cond.push_back(temp);
	}

	for (int i = 0; i < conn.size(); ++i) {
		vector<Gr_el*> temp;
		peaks_cond.push_back(temp);
	}

	for (int i = 0; i < conn.size(); ++i) {
		int col = i;
		for (int j = 0; j < conn[i].size(); ++j) {
			conn[i][j]->color = col;
		}
	}

	for (int i = 0; i < peaks.size(); ++i) {
		for (int j = 0; j < peaks[i].size(); ++j) {
			if (ver[i]->color != peaks[i][j]->color)
				set_peaks_cond(ver[i]->color, peaks[i][j]->color);
		}
	}

	for (int i = 0; i < ver_cond.size(); ++i) {
		ver_cond[i]->indeg = ver_cond[i]->outdeg = 0;
	}

	for (int i = 0; i < peaks_cond.size(); ++i) {
		for (int j = 0; j < peaks_cond[i].size(); ++j) {
			if (ver_cond[i]->number != peaks_cond[i][j]->number) {
				ver_cond[i]->outdeg++;
				ver_cond[peaks_cond[i][j]->number]->indeg++;
			}
		}
	}

	int max_outdeg_zero = 0, max_indeg_zero = 0;

	for (int i = 0; i < ver_cond.size(); ++i) {
		if (ver_cond[i]->indeg == 0)
			max_indeg_zero++;
		if (ver_cond[i]->outdeg == 0)
			max_outdeg_zero++;
	}

	max_indeg_zero > max_outdeg_zero ? cout << max_indeg_zero : cout << max_outdeg_zero;
}

void Graph::DFS_vis(Gr_el& u, vector<vector<Gr_el*>>& p) {
	u.time_in = time++;
	u.color = 1;
	for (int i = 0; i < p[u.number].size(); ++i) {
		if (p[u.number][i]->color == 0) {
			p[u.number][i]->parent = u.number;
			DFS_vis(*p[u.number][i], p);
		}
	}
	Gr_el* temp = &u;
	sort_ver.push_back(temp);
	u.color = 2;
	u.time_out = time++;
}

void Graph::DFS_vis1(Gr_el& u, vector<vector<Gr_el*>>& p, vector<Gr_el*>& temp){
	u.time_in = time++;
	u.color = 1;
	for (int i = 0; i < p[u.number].size(); ++i) {
		if (p[u.number][i]->color == 0) {
			p[u.number][i]->parent = u.number;
			DFS_vis1(*p[u.number][i], p, temp);
		}
	}
	u.color = 2;
	u.time_out = time++;
	temp.push_back(&u);
}
