#include <iostream>
#include <queue>
#include <vector>

using std::vector;
using std::queue;

class Graph {
private:
	class Gr_el {
	public:
		size_t color;
		size_t parent;
		size_t number;
		size_t dist;
		Gr_el(int number) {
			this->number = number;
		}
	};
	vector <Gr_el*> ver;
	vector <vector<Gr_el*>> peaks;
public:
	Graph(size_t n);
	~Graph() {
		for (size_t i = 0; i < ver.size(); ++i)
			delete ver[i];
	}
	void BFS(size_t s);
	void set_peak(size_t f_p, size_t s_p);
	size_t ans(size_t leo, size_t  matt, size_t milk);
};

int main() {
	size_t n, m, leo, matt, milk;
	std::cin >> n >> m >> leo >> matt >> milk;
	Graph gr(n);
	for (size_t i = 0; i < m; ++i) {
		size_t first_p, second_p;
		std::cin >> first_p >> second_p;
		gr.set_peak(first_p, second_p);
	}
	std::cout << gr.ans(leo, matt, milk);
	return 0;
}

void Graph::set_peak(size_t f_p, size_t s_p) {
	peaks[f_p].push_back(ver[s_p]);
	peaks[s_p].push_back(ver[f_p]);
}

size_t Graph::ans(size_t leo, size_t matt, size_t milk) {
	BFS(milk);
	vector <Gr_el> res1;
	for (size_t i = 0; i < ver.size(); ++i) {
		res1.push_back(*ver[i]);
	}
	BFS(leo);
	vector <Gr_el> res2;
	for (size_t i = 0; i < ver.size(); ++i) {
		res2.push_back(*ver[i]);
	}
	BFS(matt);
	vector <Gr_el> res3;
	for (size_t i = 0; i < ver.size(); ++i) {
		res3.push_back(*ver[i]);
	}
	size_t min = res1[1].dist + res2[1].dist + res3[1].dist;
	for (size_t i = 2; i < ver.size(); ++i) {
		if (min > res1[i].dist + res2[i].dist + res3[i].dist)
			min = res1[i].dist + res2[i].dist + res3[i].dist;
	}
	return min;
}

Graph::Graph(size_t n) {
	for (size_t i = 0; i < n + 1; ++i) {
		Gr_el* temp = new Gr_el(i);
		ver.push_back(temp);
		vector<Gr_el*> temp1;
		peaks.push_back(temp1);
	}
}

void Graph::BFS(size_t s) {
	for (size_t i = 0; i < ver.size(); ++i) {
		ver[i]->color = 0;
		ver[i]->dist = -1;
		ver[i]->parent = -1;
	}
	ver[s]->color = 1;
	ver[s]->dist = 0;
	queue <Gr_el> Q;
	Q.push(*ver[s]);
	while (!Q.empty()) {
		Gr_el u = Q.front();
		Q.pop();
		for (size_t i = 0; i < peaks[u.number].size(); ++i) {
			if (peaks[u.number][i]->color == 0) {
				peaks[u.number][i]->color = 1;
				peaks[u.number][i]->parent = u.number;
				peaks[u.number][i]->dist = u.dist + 1;
				Q.push(*peaks[u.number][i]);
			}
		}
		ver[u.number]->color = 2;
	}
}
